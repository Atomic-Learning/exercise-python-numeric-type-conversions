
<p>In this exercise, you'll practice converting between numeric types and observe how different conversion methods work.</p>

<h2>Instructions</h2>

<p>At each stage, use <code class="language-python">print()</code> statements to check your results:</p>

<ol>
<li>Create a variable named <code class="language-python">my_number</code> and set its value to <code class="language-python">2.6</code></li>
<li>Create a variable named <code class="language-python">round_down</code> which is <code class="language-python">my_number</code> converted to an int (rounded toward zero)</li>
<li>Create a variable named <code class="language-python">round_nearest</code> which is <code class="language-python">my_number</code> rounded to the nearest integer</li>
<li>Create a variable named <code class="language-python">new_float</code> which is <code class="language-python">round_nearest</code> converted back to a float</li>
<li>Change the value of <code class="language-python">my_number</code> to <code class="language-python">-3.6</code> and re-run your code to see how the conversion functions behave with negative numbers</li>
</ol>

<h2>Code Template</h2>

<p>Begin with this template and fill in the missing conversions:</p>

<py-cell># Create my_number
my_number =
print(my_number)

# Create round_down
round_down =
print(round_down)

# Create round_nearest
round_nearest =
print(round_nearest)

# Create new_float
new_float =
print(new_float)</py-cell>

<h2>Questions to Consider</h2>

<ul>
<li>What is the difference between <code class="language-python">int()</code> and <code class="language-python">round()</code>?</li>
<li>How do they behave differently with negative numbers?</li>
<li>Can you always convert a float to an int and back without losing information?</li>
</ul>